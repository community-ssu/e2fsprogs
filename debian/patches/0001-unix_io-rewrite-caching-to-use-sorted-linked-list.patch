From c06a70bc85c5502a06cab6ebb313bfa95eae80f6 Mon Sep 17 00:00:00 2001
From: Alexander Shishkin <ext-alexander.shishkin@nokia.com>
Date: Fri, 21 Aug 2009 15:51:39 +0300
Subject: [PATCH] unix_io: rewrite caching to use sorted linked list

Signed-off-by: Alexander Shishkin <ext-alexander.shishkin@nokia.com>
---
 lib/ext2fs/unix_io.c |  414 +++++++++++++++++++++++++++++++++-----------------
 misc/mke2fs.c        |   15 ++-
 2 files changed, 286 insertions(+), 143 deletions(-)

diff --git a/lib/ext2fs/unix_io.c b/lib/ext2fs/unix_io.c
index 797fce8..53cf1c4 100644
--- a/lib/ext2fs/unix_io.c
+++ b/lib/ext2fs/unix_io.c
@@ -54,6 +54,7 @@
 #include "ext2_fs.h"
 #include "ext2fs.h"
 
+#undef NO_IO_CACHE
 /*
  * For checking structure magic numbers...
  */
@@ -64,14 +65,14 @@
 struct unix_cache {
 	char		*buf;
 	unsigned long	block;
+	unsigned long	nblocks;
 	int		access_time;
 	unsigned	dirty:1;
-	unsigned	in_use:1;
+	struct unix_cache *prev, *next;
 };
 
-#define CACHE_SIZE 8
-#define WRITE_DIRECT_SIZE 4	/* Must be smaller than CACHE_SIZE */
-#define READ_DIRECT_SIZE 4	/* Should be smaller than CACHE_SIZE */
+#define CACHE_SIZE 512
+#define CACHE_SIZE_MAX 32768
 
 struct unix_private_data {
 	int	magic;
@@ -79,7 +80,10 @@ struct unix_private_data {
 	int	flags;
 	int	access_time;
 	ext2_loff_t offset;
-	struct unix_cache cache[CACHE_SIZE];
+	struct unix_cache *cache_list;
+	int cache_size;
+	int cache_pages;
+	int cache_nodes;
 	struct struct_io_stats io_stats;
 };
 
@@ -97,7 +101,7 @@ static errcode_t unix_set_option(io_channel channel, const char *option,
 				 const char *arg);
 static errcode_t unix_get_stats(io_channel channel, io_stats *stats)
 ;
-static void reuse_cache(io_channel channel, struct unix_private_data *data,
+static void attach_cache_node(io_channel channel, struct unix_private_data *data,
 		 struct unix_cache *cache, unsigned long long block);
 static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 			       int count, void *data);
@@ -154,25 +158,25 @@ static errcode_t unix_get_stats(io_channel channel, io_stats *stats)
  * Here are the raw I/O functions
  */
 #ifndef NEED_BOUNCE_BUFFER
-static errcode_t raw_read_blk(io_channel channel,
-			      struct unix_private_data *data,
-			      unsigned long long block,
-			      int count, void *buf)
+/*static */errcode_t raw_read_blk(io_channel channel,
+		struct unix_private_data *data,
+		unsigned long long block,
+		int count, void *buf)
 {
 	errcode_t	retval;
 	ssize_t		size;
 	ext2_loff_t	location;
 	int		actual = 0;
 
-	size = (count < 0) ? -count : count * channel->block_size;
+	size = __builtin_expect(count < 0, 0) ? -count : count * channel->block_size;
 	data->io_stats.bytes_read += size;
 	location = ((ext2_loff_t) block * channel->block_size) + data->offset;
-	if (ext2fs_llseek(data->dev, location, SEEK_SET) != location) {
+	if (__builtin_expect(ext2fs_llseek(data->dev, location, SEEK_SET) != location, 0)) {
 		retval = errno ? errno : EXT2_ET_LLSEEK_FAILED;
 		goto error_out;
 	}
 	actual = read(data->dev, buf, size);
-	if (actual != size) {
+	if (__builtin_expect(actual != size, 0)) {
 		if (actual < 0)
 			actual = 0;
 		retval = EXT2_ET_SHORT_READ;
@@ -238,39 +242,36 @@ error_out:
 	memset((char *) buf+total, 0, size-actual);
 	if (channel->read_error)
 		retval = (channel->read_error)(channel, block, count, buf,
-					       size, actual, retval);
+				size, actual, retval);
 	return retval;
 }
 #endif
 
 static errcode_t raw_write_blk(io_channel channel,
-			       struct unix_private_data *data,
-			       unsigned long long block,
-			       int count, const void *buf)
+		struct unix_private_data *data,
+		unsigned long long block,
+		int count, const void *buf)
 {
 	ssize_t		size;
 	ext2_loff_t	location;
 	int		actual = 0;
 	errcode_t	retval;
 
-	if (count == 1)
-		size = channel->block_size;
-	else {
-		if (count < 0)
-			size = -count;
-		else
-			size = count * channel->block_size;
-	}
+	if (__builtin_expect(count < 0, 0))
+		size = -count;
+	else
+		size = count * channel->block_size;
+
 	data->io_stats.bytes_written += size;
 
 	location = ((ext2_loff_t) block * channel->block_size) + data->offset;
-	if (ext2fs_llseek(data->dev, location, SEEK_SET) != location) {
+	if (__builtin_expect(ext2fs_llseek(data->dev, location, SEEK_SET) != location, 0)) {
 		retval = errno ? errno : EXT2_ET_LLSEEK_FAILED;
 		goto error_out;
 	}
 
 	actual = write(data->dev, buf, size);
-	if (actual != size) {
+	if (__builtin_expect(actual != size, 0)) {
 		retval = EXT2_ET_SHORT_WRITE;
 		goto error_out;
 	}
@@ -287,92 +288,204 @@ error_out:
 /*
  * Here we implement the cache functions
  */
-
 /* Allocate the cache buffers */
 static errcode_t alloc_cache(io_channel channel,
-			     struct unix_private_data *data)
+		struct unix_private_data *data)
 {
 	errcode_t		retval;
 	struct unix_cache	*cache;
 	int			i;
 
 	data->access_time = 0;
-	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
-		cache->block = 0;
-		cache->access_time = 0;
-		cache->dirty = 0;
-		cache->in_use = 0;
-		if ((retval = ext2fs_get_mem(channel->block_size,
-					     &cache->buf)))
-			return retval;
-	}
+
+	if (!data->cache_size)
+		data->cache_size = CACHE_SIZE;
+	data->cache_pages = 0;
+	data->cache_nodes = 0;
+	data->cache_list = NULL;
 	return 0;
 }
 
+#ifndef NO_IO_CACHE
+
+#define EXT2_CACHE_LIST_REMOVE(__c) \
+	do { \
+		if ((__c)->prev) \
+			(__c)->prev->next = (__c)->next; \
+		if ((__c)->next) \
+			(__c)->next->prev = (__c)->prev; \
+		if ((__c) == data->cache_list) \
+			data->cache_list = (__c)->next; \
+	} while (0);
+
+static void free_cache_node(struct unix_private_data *data, struct unix_cache *c)
+{
+	EXT2_CACHE_LIST_REMOVE(c);
+
+	data->cache_pages -= c->nblocks;
+	if (c->buf) /* XXX: can this be NULL? */
+		ext2fs_free_mem(&c->buf);
+	ext2fs_free_mem(&c);
+	data->cache_nodes--;
+}
+
 /* Free the cache buffers */
 static void free_cache(struct unix_private_data *data)
 {
-	struct unix_cache	*cache;
+	struct unix_cache	*cache = data->cache_list, *next;
 	int			i;
 
+	while (cache) {
+		next = cache->next;
+		free_cache_node(data, cache);
+		cache = next;
+	}
+
 	data->access_time = 0;
-	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
-		cache->block = 0;
-		cache->access_time = 0;
-		cache->dirty = 0;
-		cache->in_use = 0;
-		if (cache->buf)
-			ext2fs_free_mem(&cache->buf);
-		cache->buf = 0;
+	data->cache_nodes = 0;
+	data->cache_list = NULL;
+}
+
+static inline int is_cache_hit(struct unix_cache *cache,
+		unsigned long long block)
+{
+	if (cache->block <= block && cache->block + cache->nblocks >= block)
+		return 1;
+
+	return 0;
+}
+
+static void cache_walker(io_channel channel, struct unix_private_data *data,
+		const struct unix_cache *cache); /* fwd decl */
+
+static void evict_cache_node(io_channel channel, struct unix_private_data *data,
+		struct unix_cache *skip)
+{
+	struct unix_cache *tmp, *cache;
+
+	for (cache = tmp = data->cache_list; cache; cache = cache->next)
+		if (tmp->access_time > cache->access_time && cache != skip)
+			tmp = cache;
+
+	if (tmp != skip) {
+		cache_walker(channel, data, tmp);
+		free_cache_node(data, tmp);
 	}
 }
 
-#ifndef NO_IO_CACHE
 /*
  * Try to find a block in the cache.  If the block is not found, and
  * eldest is a non-zero pointer, then fill in eldest with the cache
  * entry to that should be reused.
  */
-static struct unix_cache *find_cached_block(struct unix_private_data *data,
-					    unsigned long long block,
-					    struct unix_cache **eldest)
+static struct unix_cache *find_cached_block(io_channel channel,
+		unsigned long long block, char **buf)
 {
-	struct unix_cache	*cache, *unused_cache, *oldest_cache;
-	int			i;
-
-	unused_cache = oldest_cache = 0;
-	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
-		if (!cache->in_use) {
-			if (!unused_cache)
-				unused_cache = cache;
-			continue;
-		}
-		if (cache->block == block) {
-			cache->access_time = ++data->access_time;
+	struct unix_cache *cache;
+	struct unix_private_data *data =
+		(struct unix_private_data *)channel->private_data;
+
+	for (cache = data->cache_list; cache; cache = cache->next)
+		if (is_cache_hit(cache, block)) {
+			/* if block is not yet there, extend the cache */
+			if (cache->block + cache->nblocks == block) {
+				if (data->cache_pages >= data->cache_size)
+					evict_cache_node(channel, data, cache);
+
+				if (data->cache_pages >= data->cache_size) {
+					evict_cache_node(channel, data, NULL);
+					return NULL;
+				}
+
+				cache->nblocks++;
+				cache->buf = realloc(cache->buf,
+						cache->nblocks * channel->block_size);
+				data->cache_pages++;
+			}
+
+			*buf = cache->buf + (block - cache->block) *
+				channel->block_size;
 			return cache;
 		}
-		if (!oldest_cache ||
-		    (cache->access_time < oldest_cache->access_time))
-			oldest_cache = cache;
+	return NULL;
+}
+
+static struct unix_cache *new_cache_node(io_channel channel)
+{
+	struct unix_cache *cache;
+	struct unix_private_data *data;
+	int retval;
+
+	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
+	data = (struct unix_private_data *) channel->private_data;
+	EXT2_CHECK_MAGIC(data, EXT2_ET_MAGIC_UNIX_IO_CHANNEL);
+
+	if (data->cache_pages >= data->cache_size)
+		evict_cache_node(channel, data, NULL);
+
+	retval = ext2fs_get_mem(sizeof(struct unix_cache), &cache);
+	if (retval)
+		return NULL;
+
+	cache->dirty = 0;
+	retval = ext2fs_get_mem(channel->block_size, &cache->buf);
+	if (retval) {
+		ext2fs_free_mem(&cache);
+		return NULL;
 	}
-	if (eldest)
-		*eldest = (unused_cache) ? unused_cache : oldest_cache;
-	return 0;
+
+	cache->prev = cache->next = NULL;
+	cache->block = 0;
+	cache->nblocks = 0;
+	cache->access_time = 0;
+	data->cache_nodes++;
+
+	return cache;
 }
 
-/*
- * Reuse a particular cache entry for another block.
- */
-static void reuse_cache(io_channel channel, struct unix_private_data *data,
-		 struct unix_cache *cache, unsigned long long block)
+static void attach_cache_node(io_channel channel, struct unix_private_data *data,
+		struct unix_cache *cache, unsigned long long block)
 {
-	if (cache->dirty && cache->in_use)
-		raw_write_blk(channel, data, cache->block, 1, cache->buf);
+	struct unix_cache *tmp, *best = data->cache_list;
+
+	/* insert ourselves so that sorted order is maintained */
+	if (data->cache_list && block < data->cache_list->block) {
+		cache->next = data->cache_list;
+		cache->prev = NULL;
+		data->cache_list->prev = cache;
+		data->cache_list = cache;
+	} else if (data->cache_list) {
+		for (best = tmp = data->cache_list; tmp; tmp = tmp->next)
+			if (tmp->block + tmp->nblocks <= block) /* XXX: "<" */
+				best = tmp;
+			else
+				break;
+
+		cache->prev = best;
+		cache->next = best->next;
+		if (best->next)
+			best->next->prev = cache;
+		best->next = cache;
+	} else
+		data->cache_list = cache;
 
-	cache->in_use = 1;
 	cache->dirty = 0;
 	cache->block = block;
+	cache->nblocks = 1;
 	cache->access_time = ++data->access_time;
+	data->cache_pages++;
+}
+
+
+static void cache_walker(io_channel channel, struct unix_private_data *data,
+		const struct unix_cache *cache)
+{
+	int retval;
+
+	if (!cache->dirty)
+		return;
+
+	raw_write_blk(channel, data, cache->block, cache->nblocks, cache->buf);
 }
 
 /*
@@ -384,28 +497,15 @@ static errcode_t flush_cached_blocks(io_channel channel,
 
 {
 	struct unix_cache	*cache;
-	errcode_t		retval, retval2;
 	int			i;
 
-	retval2 = 0;
-	for (i=0, cache = data->cache; i < CACHE_SIZE; i++, cache++) {
-		if (!cache->in_use)
-			continue;
-
-		if (invalidate)
-			cache->in_use = 0;
+	if (!invalidate)
+		return 0;
 
-		if (!cache->dirty)
-			continue;
+	for (cache = data->cache_list; cache; cache = cache->next)
+		cache_walker(channel, data, cache);
 
-		retval = raw_write_blk(channel, data,
-				       cache->block, 1, cache->buf);
-		if (retval)
-			retval2 = retval;
-		else
-			cache->dirty = 0;
-	}
-	return retval2;
+	return 0;
 }
 #endif /* NO_IO_CACHE */
 
@@ -538,7 +638,7 @@ static errcode_t unix_close(io_channel channel)
 		return 0;
 
 #ifndef NO_IO_CACHE
-	retval = flush_cached_blocks(channel, data, 0);
+	retval = flush_cached_blocks(channel, data, 1);
 #endif
 
 	if (close(data->dev) < 0)
@@ -563,7 +663,7 @@ static errcode_t unix_set_blksize(io_channel channel, int blksize)
 
 	if (channel->block_size != blksize) {
 #ifndef NO_IO_CACHE
-		if ((retval = flush_cached_blocks(channel, data, 0)))
+		if ((retval = flush_cached_blocks(channel, data, 1)))
 			return retval;
 #endif
 
@@ -576,14 +676,15 @@ static errcode_t unix_set_blksize(io_channel channel, int blksize)
 }
 
 
+#define READS_BYPASS_CACHE
 static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 			       int count, void *buf)
 {
 	struct unix_private_data *data;
-	struct unix_cache *cache, *reuse[READ_DIRECT_SIZE];
+	struct unix_cache *cache;
 	errcode_t	retval;
-	char		*cp;
-	int		i, j;
+	char		*cp, *mybuf;
+	int		i, j, bytesleft = 0;
 
 	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
 	data = (struct unix_private_data *) channel->private_data;
@@ -592,51 +693,64 @@ static errcode_t unix_read_blk64(io_channel channel, unsigned long long block,
 #ifdef NO_IO_CACHE
 	return raw_read_blk(channel, data, block, count, buf);
 #else
-	/*
-	 * If we're doing an odd-sized read or a very large read,
-	 * flush out the cache and then do a direct read.
-	 */
-	if (count < 0 || count > WRITE_DIRECT_SIZE) {
-		if ((retval = flush_cached_blocks(channel, data, 0)))
-			return retval;
-		return raw_read_blk(channel, data, block, count, buf);
+	if (count < 0) {
+		bytesleft = -count % channel->block_size;
+		count = -count / channel->block_size;
 	}
 
 	cp = buf;
 	while (count > 0) {
 		/* If it's in the cache, use it! */
-		if ((cache = find_cached_block(data, block, &reuse[0]))) {
+		if ((cache = find_cached_block(channel, block, &mybuf))) {
 #ifdef DEBUG
 			printf("Using cached block %lu\n", block);
 #endif
-			memcpy(cp, cache->buf, channel->block_size);
+			memcpy(cp, mybuf, channel->block_size);
 			count--;
 			block++;
 			cp += channel->block_size;
 			continue;
 		}
-		/*
-		 * Find the number of uncached blocks so we can do a
-		 * single read request
-		 */
-		for (i=1; i < count; i++)
-			if (find_cached_block(data, block+i, &reuse[i]))
-				break;
+#ifdef READS_BYPASS_CACHE
+		if (!cache) {
+			raw_read_blk(channel, data, block, 1, cp);
+			count--;
+			block++;
+			cp += channel->block_size;
+			continue;
+		}
+#endif
+
+		cache = new_cache_node(channel);
 #ifdef DEBUG
 		printf("Reading %d blocks starting at %lu\n", i, block);
 #endif
-		if ((retval = raw_read_blk(channel, data, block, i, cp)))
+		attach_cache_node(channel, data, cache, block++);
+		if ((retval = raw_read_blk(channel, data, block, 1, cp)))
 			return retval;
 
-		/* Save the results in the cache */
-		for (j=0; j < i; j++) {
-			count--;
-			cache = reuse[j];
-			reuse_cache(channel, data, cache, block++);
-			memcpy(cache->buf, cp, channel->block_size);
-			cp += channel->block_size;
-		}
+		memcpy(cache->buf, cp, channel->block_size);
+		count--;
+		cp += channel->block_size;
 	}
+
+	if (bytesleft) {
+		cache = find_cached_block(channel, block, &mybuf);
+		if (!cache) {
+#ifndef READS_BYPASS_CACHE
+			cache = new_cache_node(channel);
+			attach_cache_node(channel, data, cache, block);
+			raw_read_blk(channel, data, block, 1, cache->buf);
+			memcpy(cp, cache->buf, bytesleft);
+#else
+			raw_read_blk(channel, data, block, -bytesleft, cp);
+#endif
+		} else
+			memcpy(cp, mybuf, bytesleft);
+
+		return 0;
+	}
+
 	return 0;
 #endif /* NO_IO_CACHE */
 }
@@ -654,7 +768,9 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 	struct unix_cache *cache, *reuse;
 	errcode_t	retval = 0;
 	const char	*cp;
+	char		*mybuf;
 	int		writethrough;
+	int             bytesleft = 0;
 
 	EXT2_CHECK_MAGIC(channel, EXT2_ET_MAGIC_IO_CHANNEL);
 	data = (struct unix_private_data *) channel->private_data;
@@ -664,16 +780,6 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 	return raw_write_blk(channel, data, block, count, buf);
 #else
 	/*
-	 * If we're doing an odd-sized write or a very large write,
-	 * flush out the cache completely and then do a direct write.
-	 */
-	if (count < 0 || count > WRITE_DIRECT_SIZE) {
-		if ((retval = flush_cached_blocks(channel, data, 1)))
-			return retval;
-		return raw_write_blk(channel, data, block, count, buf);
-	}
-
-	/*
 	 * For a moderate-sized multi-block write, first force a write
 	 * if we're in write-through cache mode, and then fill the
 	 * cache with the blocks.
@@ -682,19 +788,38 @@ static errcode_t unix_write_blk64(io_channel channel, unsigned long long block,
 	if (writethrough)
 		retval = raw_write_blk(channel, data, block, count, buf);
 
+	if (count < 0) {
+		bytesleft = -count % channel->block_size;
+		count = -count / channel->block_size;
+	}
+
 	cp = buf;
 	while (count > 0) {
-		cache = find_cached_block(data, block, &reuse);
+		cache = find_cached_block(channel, block, &mybuf);
 		if (!cache) {
-			cache = reuse;
-			reuse_cache(channel, data, cache, block);
-		}
-		memcpy(cache->buf, cp, channel->block_size);
+			cache = new_cache_node(channel);
+			attach_cache_node(channel, data, cache, block);
+			memcpy(cache->buf, cp, channel->block_size);
+		} else
+			memcpy(mybuf, cp, channel->block_size);
 		cache->dirty = !writethrough;
 		count--;
 		block++;
 		cp += channel->block_size;
 	}
+
+	if (bytesleft) {
+		cache = find_cached_block(channel, block, &mybuf);
+		if (!cache) {
+			cache = new_cache_node(channel);
+			attach_cache_node(channel, data, cache, block);
+			raw_read_blk(channel, data, block, 1, cache->buf);
+			memcpy(cache->buf, cp, bytesleft);
+		} else
+			memcpy(mybuf, cp, bytesleft);
+		cache->dirty = !writethrough;
+	}
+
 	return retval;
 #endif /* NO_IO_CACHE */
 }
@@ -775,6 +900,13 @@ static errcode_t unix_set_option(io_channel channel, const char *option,
 		if (data->offset < 0)
 			return EXT2_ET_INVALID_ARGUMENT;
 		return 0;
+	} else if (!strcmp(option, "cache_size")) {
+		data->cache_size = atoi(arg);
+
+		if (data->cache_size < CACHE_SIZE)
+			data->cache_size = CACHE_SIZE;
+		else if (data->cache_size > CACHE_SIZE_MAX)
+			data->cache_size = CACHE_SIZE_MAX;
 	}
 	return EXT2_ET_INVALID_ARGUMENT;
 }
diff --git a/misc/mke2fs.c b/misc/mke2fs.c
index 3d830fc..c82ef34 100644
--- a/misc/mke2fs.c
+++ b/misc/mke2fs.c
@@ -92,6 +92,7 @@ char *mount_dir;
 char *journal_device;
 int sync_kludge;	/* Set using the MKE2FS_SYNC env. option */
 char **fs_types;
+int cache_size;
 
 profile_t	profile;
 
@@ -102,7 +103,7 @@ static void usage(void)
 {
 	fprintf(stderr, _("Usage: %s [-c|-l filename] [-b block-size] "
 	"[-f fragment-size]\n\t[-i bytes-per-inode] [-I inode-size] "
-	"[-J journal-options]\n"
+	"[-J journal-options] [-C io-cache-size]\n"
 	"\t[-G meta group size] [-N number-of-inodes]\n"
 	"\t[-m reserved-blocks-percentage] [-o creator-os]\n"
 	"\t[-g blocks-per-group] [-L volume-label] "
@@ -1162,7 +1163,7 @@ static void PRS(int argc, char *argv[])
 	}
 
 	while ((c = getopt (argc, argv,
-		    "b:cf:g:G:i:jl:m:no:qr:s:t:vE:FI:J:L:M:N:O:R:ST:V")) != EOF) {
+		    "b:cf:g:G:i:jl:m:no:qr:s:t:vE:FI:J:L:M:N:O:R:ST:VC:")) != EOF) {
 		switch (c) {
 		case 'b':
 			blocksize = strtol(optarg, &tmp, 0);
@@ -1332,6 +1333,11 @@ static void PRS(int argc, char *argv[])
 			/* Print version number and exit */
 			show_version_only++;
 			break;
+		case 'C':
+			/* cache size */
+			cache_size = atoi(optarg);
+			break;
+
 		default:
 			usage();
 		}
@@ -1866,6 +1872,11 @@ int main (int argc, char *argv[])
 		32768 : fs->blocksize * 8);
 	io_channel_set_options(fs->io, tdb_string);
 
+	if (cache_size) {
+		sprintf(tdb_string, "cache_size=%d", cache_size);
+		io_channel_set_options(fs->io, tdb_string);
+	}
+
 	if (fs_param.s_flags & EXT2_FLAGS_TEST_FILESYS)
 		fs->super->s_flags |= EXT2_FLAGS_TEST_FILESYS;
 
-- 
1.6.3.3

